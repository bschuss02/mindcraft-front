{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { DEFAULT_TOUCH_SLOP } from \"../constants\";\nimport { EventTypes } from \"../interfaces\";\n\nvar ScaleGestureDetector = function () {\n  function ScaleGestureDetector(callbacks) {\n    _classCallCheck(this, ScaleGestureDetector);\n\n    _defineProperty(this, \"onScaleBegin\", void 0);\n\n    _defineProperty(this, \"onScale\", void 0);\n\n    _defineProperty(this, \"onScaleEnd\", void 0);\n\n    _defineProperty(this, \"focusX\", void 0);\n\n    _defineProperty(this, \"focusY\", void 0);\n\n    _defineProperty(this, \"currentSpan\", void 0);\n\n    _defineProperty(this, \"prevSpan\", void 0);\n\n    _defineProperty(this, \"initialSpan\", void 0);\n\n    _defineProperty(this, \"currentTime\", void 0);\n\n    _defineProperty(this, \"prevTime\", void 0);\n\n    _defineProperty(this, \"inProgress\", false);\n\n    _defineProperty(this, \"spanSlop\", void 0);\n\n    _defineProperty(this, \"minSpan\", void 0);\n\n    this.onScaleBegin = callbacks.onScaleBegin;\n    this.onScale = callbacks.onScale;\n    this.onScaleEnd = callbacks.onScaleEnd;\n    this.spanSlop = DEFAULT_TOUCH_SLOP * 2;\n    this.minSpan = 0;\n  }\n\n  _createClass(ScaleGestureDetector, [{\n    key: \"onTouchEvent\",\n    value: function onTouchEvent(event, tracker) {\n      this.currentTime = event.time;\n      var action = event.eventType;\n      var numOfPointers = tracker.getTrackedPointersCount();\n      var streamComplete = action === EventTypes.UP || action === EventTypes.ADDITIONAL_POINTER_UP || action === EventTypes.CANCEL;\n\n      if (action === EventTypes.DOWN || streamComplete) {\n        if (this.inProgress) {\n          this.onScaleEnd(this);\n          this.inProgress = false;\n          this.initialSpan = 0;\n        }\n\n        if (streamComplete) {\n          return true;\n        }\n      }\n\n      var configChanged = action === EventTypes.DOWN || action === EventTypes.ADDITIONAL_POINTER_UP || action === EventTypes.ADDITIONAL_POINTER_DOWN;\n      var pointerUp = action === EventTypes.ADDITIONAL_POINTER_UP;\n      var ignoredPointer = pointerUp ? event.pointerId : undefined;\n      var div = pointerUp ? numOfPointers - 1 : numOfPointers;\n      var sumX = tracker.getSumX(ignoredPointer);\n      var sumY = tracker.getSumY(ignoredPointer);\n      var focusX = sumX / div;\n      var focusY = sumY / div;\n      var devSumX = 0;\n      var devSumY = 0;\n      tracker.getData().forEach(function (value, key) {\n        if (key === ignoredPointer) {\n          return;\n        }\n\n        devSumX += Math.abs(value.lastX - focusX);\n        devSumY += Math.abs(value.lastY - focusY);\n      });\n      var devX = devSumX / div;\n      var devY = devSumY / div;\n      var spanX = devX * 2;\n      var spanY = devY * 2;\n      var span = Math.hypot(spanX, spanY);\n      var wasInProgress = this.inProgress;\n      this.focusX = focusX;\n      this.focusY = focusY;\n\n      if (this.inProgress && (span < this.minSpan || configChanged)) {\n        this.onScaleEnd(this);\n        this.inProgress = false;\n        this.initialSpan = span;\n      }\n\n      if (configChanged) {\n        this.initialSpan = this.prevSpan = this.currentSpan = span;\n      }\n\n      if (!this.inProgress && span >= this.minSpan && (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)) {\n        this.prevSpan = this.currentSpan = span;\n        this.prevTime = this.currentTime;\n        this.inProgress = this.onScaleBegin(this);\n      }\n\n      if (action !== EventTypes.MOVE) {\n        return true;\n      }\n\n      this.currentSpan = span;\n\n      if (this.inProgress && !this.onScale(this)) {\n        return true;\n      }\n\n      this.prevSpan = this.currentSpan;\n      this.prevTime = this.currentTime;\n      return true;\n    }\n  }, {\n    key: \"getCurrentSpan\",\n    value: function getCurrentSpan() {\n      return this.currentSpan;\n    }\n  }, {\n    key: \"getFocusX\",\n    value: function getFocusX() {\n      return this.focusX;\n    }\n  }, {\n    key: \"getFocusY\",\n    value: function getFocusY() {\n      return this.focusY;\n    }\n  }, {\n    key: \"getTimeDelta\",\n    value: function getTimeDelta() {\n      return this.currentTime - this.prevTime;\n    }\n  }, {\n    key: \"getScaleFactor\",\n    value: function getScaleFactor(numOfPointers) {\n      if (numOfPointers < 2) {\n        return 1;\n      }\n\n      return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;\n    }\n  }]);\n\n  return ScaleGestureDetector;\n}();\n\nexport { ScaleGestureDetector as default };","map":{"version":3,"sources":["ScaleGestureDetector.ts"],"names":["constructor","callbacks","DEFAULT_TOUCH_SLOP","onTouchEvent","event","action","numOfPointers","tracker","streamComplete","EventTypes","configChanged","pointerUp","ignoredPointer","div","sumX","sumY","focusX","focusY","devSumX","devSumY","key","Math","value","devX","devY","spanX","spanY","span","wasInProgress","getCurrentSpan","getFocusX","getFocusY","getTimeDelta","getScaleFactor"],"mappings":"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","sourcesContent":["import { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedEvent, EventTypes } from '../interfaces';\n\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface ScaleGestureListener {\n  onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  onScale: (detector: ScaleGestureDetector) => boolean;\n  onScaleEnd: (detector: ScaleGestureDetector) => void;\n}\n\nexport default class ScaleGestureDetector implements ScaleGestureListener {\n  public onScaleBegin: (detector: ScaleGestureDetector) => boolean;\n  public onScale: (detector: ScaleGestureDetector) => boolean;\n  public onScaleEnd: (detector: ScaleGestureDetector) => void;\n\n  private focusX!: number;\n  private focusY!: number;\n\n  private currentSpan!: number;\n  private prevSpan!: number;\n  private initialSpan!: number;\n\n  private currentTime!: number;\n  private prevTime!: number;\n\n  private inProgress = false;\n\n  private spanSlop: number;\n  private minSpan: number;\n\n  public constructor(callbacks: ScaleGestureListener) {\n    this.onScaleBegin = callbacks.onScaleBegin;\n    this.onScale = callbacks.onScale;\n    this.onScaleEnd = callbacks.onScaleEnd;\n\n    this.spanSlop = DEFAULT_TOUCH_SLOP * 2;\n    this.minSpan = 0;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    this.currentTime = event.time;\n\n    const action: EventTypes = event.eventType;\n    const numOfPointers = tracker.getTrackedPointersCount();\n\n    const streamComplete: boolean =\n      action === EventTypes.UP ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.CANCEL;\n\n    if (action === EventTypes.DOWN || streamComplete) {\n      if (this.inProgress) {\n        this.onScaleEnd(this);\n        this.inProgress = false;\n        this.initialSpan = 0;\n      }\n\n      if (streamComplete) {\n        return true;\n      }\n    }\n\n    const configChanged: boolean =\n      action === EventTypes.DOWN ||\n      action === EventTypes.ADDITIONAL_POINTER_UP ||\n      action === EventTypes.ADDITIONAL_POINTER_DOWN;\n\n    const pointerUp = action === EventTypes.ADDITIONAL_POINTER_UP;\n\n    const ignoredPointer: number | undefined = pointerUp\n      ? event.pointerId\n      : undefined;\n\n    //Determine focal point\n\n    const div: number = pointerUp ? numOfPointers - 1 : numOfPointers;\n\n    const sumX = tracker.getSumX(ignoredPointer);\n    const sumY = tracker.getSumY(ignoredPointer);\n\n    const focusX = sumX / div;\n    const focusY = sumY / div;\n\n    //Determine average deviation from focal point\n\n    let devSumX = 0;\n    let devSumY = 0;\n\n    tracker.getData().forEach((value, key) => {\n      if (key === ignoredPointer) {\n        return;\n      }\n\n      devSumX += Math.abs(value.lastX - focusX);\n      devSumY += Math.abs(value.lastY - focusY);\n    });\n\n    const devX: number = devSumX / div;\n    const devY: number = devSumY / div;\n\n    const spanX: number = devX * 2;\n    const spanY: number = devY * 2;\n\n    const span = Math.hypot(spanX, spanY);\n\n    //Begin/end events\n    const wasInProgress: boolean = this.inProgress;\n    this.focusX = focusX;\n    this.focusY = focusY;\n\n    if (this.inProgress && (span < this.minSpan || configChanged)) {\n      this.onScaleEnd(this);\n      this.inProgress = false;\n      this.initialSpan = span;\n    }\n\n    if (configChanged) {\n      this.initialSpan = this.prevSpan = this.currentSpan = span;\n    }\n\n    if (\n      !this.inProgress &&\n      span >= this.minSpan &&\n      (wasInProgress || Math.abs(span - this.initialSpan) > this.spanSlop)\n    ) {\n      this.prevSpan = this.currentSpan = span;\n      this.prevTime = this.currentTime;\n      this.inProgress = this.onScaleBegin(this);\n    }\n\n    //Handle motion\n    if (action !== EventTypes.MOVE) {\n      return true;\n    }\n\n    this.currentSpan = span;\n\n    if (this.inProgress && !this.onScale(this)) {\n      return true;\n    }\n\n    this.prevSpan = this.currentSpan;\n    this.prevTime = this.currentTime;\n\n    return true;\n  }\n\n  public getCurrentSpan(): number {\n    return this.currentSpan;\n  }\n\n  public getFocusX(): number {\n    return this.focusX;\n  }\n\n  public getFocusY(): number {\n    return this.focusY;\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime - this.prevTime;\n  }\n\n  public getScaleFactor(numOfPointers: number): number {\n    if (numOfPointers < 2) {\n      return 1;\n    }\n\n    return this.prevSpan > 0 ? this.currentSpan / this.prevSpan : 1;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}