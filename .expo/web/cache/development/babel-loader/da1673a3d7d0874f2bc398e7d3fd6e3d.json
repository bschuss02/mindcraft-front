{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar InteractionManager = function () {\n  function InteractionManager() {\n    _classCallCheck(this, InteractionManager);\n\n    _defineProperty(this, \"waitForRelations\", new Map());\n\n    _defineProperty(this, \"simultaneousRelations\", new Map());\n  }\n\n  _createClass(InteractionManager, [{\n    key: \"configureInteractions\",\n    value: function configureInteractions(handler, config) {\n      this.dropRelationsForHandlerWithTag(handler.getTag());\n\n      if (config.waitFor) {\n        var waitFor = [];\n        config.waitFor.forEach(function (otherHandler) {\n          if (typeof otherHandler === 'number') {\n            waitFor.push(otherHandler);\n          } else {\n            waitFor.push(otherHandler.handlerTag);\n          }\n        });\n        this.waitForRelations.set(handler.getTag(), waitFor);\n      }\n\n      if (config.simultaneousHandlers) {\n        var simultaneousHandlers = [];\n        config.simultaneousHandlers.forEach(function (otherHandler) {\n          if (typeof otherHandler === 'number') {\n            simultaneousHandlers.push(otherHandler);\n          } else {\n            simultaneousHandlers.push(otherHandler.handlerTag);\n          }\n        });\n        this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n      }\n    }\n  }, {\n    key: \"shouldWaitForHandlerFailure\",\n    value: function shouldWaitForHandlerFailure(handler, otherHandler) {\n      var waitFor = this.waitForRelations.get(handler.getTag());\n\n      if (!waitFor) {\n        return false;\n      }\n\n      var shouldWait = false;\n      waitFor.forEach(function (tag) {\n        if (tag === otherHandler.getTag()) {\n          shouldWait = true;\n          return;\n        }\n      });\n      return shouldWait;\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler, otherHandler) {\n      var simultaneousHandlers = this.simultaneousRelations.get(handler.getTag());\n\n      if (!simultaneousHandlers) {\n        return false;\n      }\n\n      var shouldRecognizeSimultaneously = false;\n      simultaneousHandlers.forEach(function (tag) {\n        if (tag === otherHandler.getTag()) {\n          shouldRecognizeSimultaneously = true;\n          return;\n        }\n      });\n      return shouldRecognizeSimultaneously;\n    }\n  }, {\n    key: \"shouldRequireHandlerToWaitForFailure\",\n    value: function shouldRequireHandlerToWaitForFailure(_handler, _otherHandler) {\n      return false;\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(_handler, _otherHandler) {\n      return false;\n    }\n  }, {\n    key: \"dropRelationsForHandlerWithTag\",\n    value: function dropRelationsForHandlerWithTag(handlerTag) {\n      this.waitForRelations.delete(handlerTag);\n      this.simultaneousRelations.delete(handlerTag);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.waitForRelations.clear();\n      this.simultaneousRelations.clear();\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!this.instance) {\n        this.instance = new InteractionManager();\n      }\n\n      return this.instance;\n    }\n  }]);\n\n  return InteractionManager;\n}();\n\nexport { InteractionManager as default };\n\n_defineProperty(InteractionManager, \"instance\", void 0);","map":{"version":3,"sources":["InteractionManager.ts"],"names":["InteractionManager","constructor","configureInteractions","handler","config","waitFor","otherHandler","simultaneousHandlers","shouldWaitForHandlerFailure","shouldWait","tag","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","shouldHandlerBeCancelledBy","dropRelationsForHandlerWithTag","reset","getInstance"],"mappings":"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","sourcesContent":["import GestureHandler from '../handlers/GestureHandler';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private static instance: InteractionManager;\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n\n  // Private becaues of singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  public configureInteractions(handler: GestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((otherHandler: Handler): void => {\n        // New API reference\n        if (typeof otherHandler === 'number') {\n          waitFor.push(otherHandler);\n        } else {\n          // Old API reference\n          waitFor.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((otherHandler: Handler): void => {\n        if (typeof otherHandler === 'number') {\n          simultaneousHandlers.push(otherHandler);\n        } else {\n          simultaneousHandlers.push(otherHandler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n    if (!waitFor) {\n      return false;\n    }\n\n    let shouldWait = false;\n\n    waitFor.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const simultaneousHandlers: number[] | undefined =\n      this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n\n    let shouldRecognizeSimultaneously = false;\n\n    simultaneousHandlers.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n\n    return shouldRecognizeSimultaneously;\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    //TODO: Implement logic\n    return false;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n\n  public static getInstance(): InteractionManager {\n    if (!this.instance) {\n      this.instance = new InteractionManager();\n    }\n\n    return this.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}