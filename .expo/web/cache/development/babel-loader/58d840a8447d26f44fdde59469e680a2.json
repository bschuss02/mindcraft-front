{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as queryString from 'query-string';\nimport fromEntries from \"./fromEntries\";\nimport validatePathConfig from \"./validatePathConfig\";\n\nvar getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  var configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};\n  var path = '/';\n  var current = state;\n  var allParams = {};\n\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern;\n    var focusedParams;\n    var focusedRoute = getActiveRoute(state);\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n\n    var _loop2 = function _loop2() {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n        var currentParams = fromEntries(Object.entries(route.params).map(function (_ref) {\n          var _ref3 = _slicedToArray(_ref, 2),\n              key = _ref3[0],\n              value = _ref3[1];\n\n          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          focusedParams = _objectSpread({}, currentParams);\n          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(function (p) {\n            return p.startsWith(':');\n          }).forEach(function (p) {\n            var name = getParamName(p);\n\n            if (focusedParams) {\n              delete focusedParams[name];\n            }\n          });\n        }\n      }\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    };\n\n    while (route.name in currentOptions && hasNext) {\n      _loop2();\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = getParamName(p);\n\n        if (p === '*') {\n          return route.name;\n        }\n\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n\n          return encodeURIComponent(value);\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n\n      var query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n\n      if (query) {\n        path += \"?\" + query;\n      }\n    }\n\n    current = route.state;\n  };\n\n  while (current) {\n    var _currentOptions$route, _pattern;\n\n    _loop();\n  }\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\n\nvar getParamName = function getParamName(pattern) {\n  return pattern.replace(/^:/, '').replace(/\\?$/, '');\n};\n\nvar joinPaths = function joinPaths() {\n  var _ref4;\n\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return (_ref4 = []).concat.apply(_ref4, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\n\nvar createConfigItem = function createConfigItem(config, parentPattern) {\n  var _pattern2;\n\n  if (typeof config === 'string') {\n    var _pattern3 = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return {\n      pattern: _pattern3\n    };\n  }\n\n  var pattern;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n\n  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n};\n\nvar createNormalizedConfigs = function createNormalizedConfigs(options, pattern) {\n  return fromEntries(Object.entries(options).map(function (_ref2) {\n    var _ref5 = _slicedToArray(_ref2, 2),\n        name = _ref5[0],\n        c = _ref5[1];\n\n    var result = createConfigItem(c, pattern);\n    return [name, result];\n  }));\n};","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["queryString","fromEntries","validatePathConfig","getActiveRoute","state","route","index","routes","length","getPathFromState","options","Error","configs","screens","createNormalizedConfigs","path","current","allParams","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","name","push","params","stringify","currentParams","Object","entries","map","key","value","String","assign","split","filter","p","startsWith","forEach","getParamName","undefined","nextRoute","nestedConfig","join","endsWith","encodeURIComponent","param","query","sort","replace","joinPaths","paths","concat","Boolean","createConfigItem","config","parentPattern","exact","c","result"],"mappings":"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","sourceRoot":"../../src","sourcesContent":["import * as queryString from 'query-string';\nimport fromEntries from './fromEntries';\nimport validatePathConfig from './validatePathConfig';\nconst getActiveRoute = state => {\n  const route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};\n  let path = '/';\n  let current = state;\n  const allParams = {};\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index];\n    let pattern;\n    let focusedParams;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n    let hasNext = true;\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n      if (route.params) {\n        var _currentOptions$route;\n        const stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n        const currentParams = fromEntries(Object.entries(route.params).map(_ref => {\n          let [key, value] = _ref;\n          return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n        }));\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n        if (focusedRoute === route) {\n          var _pattern;\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = {\n            ...currentParams\n          };\n          (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(p => p.startsWith(':'))\n          // eslint-disable-next-line no-loop-func\n          .forEach(p => {\n            const name = getParamName(p);\n\n            // Remove the params present in the pattern since we'll only use the rest for query string\n            if (focusedParams) {\n              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n              delete focusedParams[name];\n            }\n          });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(p => {\n        const name = getParamName(p);\n\n        // We don't know what to show for wildcard patterns\n        // Showing the route name seems ok, though whatever we show here will be incorrect\n        // Since the page doesn't actually exist\n        if (p === '*') {\n          return route.name;\n        }\n\n        // If the path has a pattern for a param, put the param in the path\n        if (p.startsWith(':')) {\n          const value = allParams[name];\n          if (value === undefined && p.endsWith('?')) {\n            // Optional params without value assigned in route.params should be ignored\n            return '';\n          }\n          return encodeURIComponent(value);\n        }\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n      const query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\nconst getParamName = pattern => pattern.replace(/^:/, '').replace(/\\?$/, '');\nconst joinPaths = function () {\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n  return [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\n};\nconst createConfigItem = (config, parentPattern) => {\n  var _pattern2;\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n    return {\n      pattern\n    };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern;\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens\n  };\n};\nconst createNormalizedConfigs = (options, pattern) => fromEntries(Object.entries(options).map(_ref2 => {\n  let [name, c] = _ref2;\n  const result = createConfigItem(c, pattern);\n  return [name, result];\n}));\n//# sourceMappingURL=getPathFromState.js.map"]},"metadata":{},"sourceType":"module"}