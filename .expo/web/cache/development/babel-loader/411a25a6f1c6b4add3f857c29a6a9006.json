{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StatusBar from \"react-native-web/dist/exports/StatusBar\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from 'react-native-reanimated';\nimport DrawerProgressContext from \"../../utils/DrawerProgressContext\";\nimport { GestureState, PanGestureHandler } from \"../GestureHandler\";\nimport Overlay from \"./Overlay\";\nvar Clock = Animated.Clock,\n    Value = Animated.Value,\n    onChange = Animated.onChange,\n    clockRunning = Animated.clockRunning,\n    startClock = Animated.startClock,\n    stopClock = Animated.stopClock,\n    spring = Animated.spring,\n    abs = Animated.abs,\n    add = Animated.add,\n    and = Animated.and,\n    block = Animated.block,\n    call = Animated.call,\n    cond = Animated.cond,\n    divide = Animated.divide,\n    eq = Animated.eq,\n    event = Animated.event,\n    greaterThan = Animated.greaterThan,\n    lessThan = Animated.lessThan,\n    max = Animated.max,\n    min = Animated.min,\n    multiply = Animated.multiply,\n    neq = Animated.neq,\n    or = Animated.or,\n    set = Animated.set,\n    sub = Animated.sub;\nvar TRUE = 1;\nvar FALSE = 0;\nvar NOOP = 0;\nvar UNSET = -1;\nvar DIRECTION_LEFT = 1;\nvar DIRECTION_RIGHT = -1;\nvar SWIPE_DISTANCE_MINIMUM = 5;\nvar DEFAULT_DRAWER_WIDTH = '80%';\nvar SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01\n};\nvar ANIMATED_ZERO = new Animated.Value(0);\nvar ANIMATED_ONE = new Animated.Value(1);\n\nvar DrawerView = function (_React$Component) {\n  _inherits(DrawerView, _React$Component);\n\n  var _super = _createSuper(DrawerView);\n\n  function DrawerView() {\n    var _this;\n\n    _classCallCheck(this, DrawerView);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _this.handleEndInteraction = function () {\n      if (_this.interactionHandle !== undefined) {\n        InteractionManager.clearInteractionHandle(_this.interactionHandle);\n        _this.interactionHandle = undefined;\n      }\n    };\n\n    _this.handleStartInteraction = function () {\n      if (_this.interactionHandle === undefined) {\n        _this.interactionHandle = InteractionManager.createInteractionHandle();\n      }\n    };\n\n    _this.getDrawerWidth = function () {\n      var _this$props = _this.props,\n          drawerStyle = _this$props.drawerStyle,\n          dimensions = _this$props.dimensions;\n\n      var _ref4 = StyleSheet.flatten(drawerStyle) || {},\n          _ref4$width = _ref4.width,\n          width = _ref4$width === void 0 ? DEFAULT_DRAWER_WIDTH : _ref4$width;\n\n      if (typeof width === 'string' && width.endsWith('%')) {\n        var percentage = Number(width.replace(/%$/, ''));\n\n        if (Number.isFinite(percentage)) {\n          return dimensions.width * (percentage / 100);\n        }\n      }\n\n      return typeof width === 'number' ? width : 0;\n    };\n\n    _this.clock = new Clock();\n    _this.isDrawerTypeFront = new Value(_this.props.drawerType === 'front' ? TRUE : FALSE);\n    _this.isOpen = new Value(_this.props.open ? TRUE : FALSE);\n    _this.nextIsOpen = new Value(UNSET);\n    _this.isSwiping = new Value(FALSE);\n    _this.initialDrawerWidth = _this.getDrawerWidth();\n    _this.gestureState = new Value(GestureState.UNDETERMINED);\n    _this.touchX = new Value(0);\n    _this.velocityX = new Value(0);\n    _this.gestureX = new Value(0);\n    _this.offsetX = new Value(0);\n    _this.position = new Value(_this.props.open ? _this.initialDrawerWidth * (_this.props.drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT) : 0);\n    _this.containerWidth = new Value(_this.props.dimensions.width);\n    _this.drawerWidth = new Value(_this.initialDrawerWidth);\n    _this.drawerOpacity = new Value(_this.props.drawerType === 'permanent' ? 1 : 0);\n    _this.drawerPosition = new Value(_this.props.drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT);\n    _this.touchDistanceFromDrawer = cond(_this.isDrawerTypeFront, cond(eq(_this.drawerPosition, DIRECTION_LEFT), max(sub(sub(_this.touchX, _this.gestureX), _this.drawerWidth), 0), min(multiply(sub(sub(_this.containerWidth, _this.drawerWidth), sub(_this.touchX, _this.gestureX)), DIRECTION_RIGHT), 0)), 0);\n    _this.swipeDistanceThreshold = new Value(_this.props.swipeDistanceThreshold);\n    _this.swipeVelocityThreshold = new Value(_this.props.swipeVelocityThreshold);\n    _this.currentOpenValue = _this.props.open;\n    _this.isStatusBarHidden = false;\n    _this.manuallyTriggerSpring = new Value(FALSE);\n\n    _this.transitionTo = function (isOpen) {\n      var toValue = new Value(0);\n      var frameTime = new Value(0);\n      var state = {\n        position: _this.position,\n        time: new Value(0),\n        finished: new Value(FALSE),\n        velocity: new Value(0)\n      };\n      return block([cond(clockRunning(_this.clock), NOOP, [set(toValue, multiply(isOpen, _this.drawerWidth, _this.drawerPosition)), set(frameTime, 0), set(state.time, 0), set(state.finished, FALSE), set(state.velocity, _this.velocityX), set(_this.isOpen, isOpen), startClock(_this.clock), call([], _this.handleStartInteraction), set(_this.manuallyTriggerSpring, FALSE)]), spring(_this.clock, state, _objectSpread(_objectSpread({}, SPRING_CONFIG), {}, {\n        toValue: toValue\n      })), cond(state.finished, [set(_this.touchX, 0), set(_this.gestureX, 0), set(_this.velocityX, 0), set(_this.offsetX, 0), stopClock(_this.clock), call([_this.isOpen], function (_ref) {\n        var _ref5 = _slicedToArray(_ref, 1),\n            value = _ref5[0];\n\n        var open = Boolean(value);\n\n        _this.handleEndInteraction();\n\n        if (open !== _this.props.open) {\n          _this.toggleDrawer(_this.props.open);\n        }\n      })])]);\n    };\n\n    _this.dragX = block([onChange(_this.isOpen, call([_this.isOpen], function (_ref2) {\n      var _ref6 = _slicedToArray(_ref2, 1),\n          value = _ref6[0];\n\n      var open = Boolean(value);\n      _this.currentOpenValue = open;\n\n      if (open !== _this.props.open) {\n        if (open) {\n          _this.props.onOpen();\n        } else {\n          _this.props.onClose();\n        }\n\n        _this.pendingOpenValue = open;\n\n        _this.forceUpdate();\n      }\n    })), onChange(_this.nextIsOpen, cond(neq(_this.nextIsOpen, UNSET), [cond(clockRunning(_this.clock), stopClock(_this.clock)), set(_this.isOpen, _this.nextIsOpen), set(_this.gestureX, 0), set(_this.nextIsOpen, UNSET)])), onChange(_this.isSwiping, call([_this.isSwiping], function (_ref3) {\n      var _ref7 = _slicedToArray(_ref3, 1),\n          value = _ref7[0];\n\n      var keyboardDismissMode = _this.props.keyboardDismissMode;\n\n      if (value === TRUE) {\n        if (keyboardDismissMode === 'on-drag') {\n          Keyboard.dismiss();\n        }\n\n        _this.toggleStatusBar(true);\n      } else {\n        _this.toggleStatusBar(_this.currentOpenValue);\n      }\n    })), onChange(_this.gestureState, cond(eq(_this.gestureState, GestureState.ACTIVE), call([], _this.handleStartInteraction))), cond(eq(_this.gestureState, GestureState.ACTIVE), [cond(_this.isSwiping, NOOP, [set(_this.isSwiping, TRUE), set(_this.offsetX, _this.position)]), set(_this.position, add(_this.offsetX, _this.gestureX, _this.touchDistanceFromDrawer)), stopClock(_this.clock)], [set(_this.isSwiping, FALSE), set(_this.touchX, 0), _this.transitionTo(cond(_this.manuallyTriggerSpring, _this.isOpen, cond(or(and(greaterThan(abs(_this.gestureX), SWIPE_DISTANCE_MINIMUM), greaterThan(abs(_this.velocityX), _this.swipeVelocityThreshold)), greaterThan(abs(_this.gestureX), _this.swipeDistanceThreshold)), cond(eq(_this.drawerPosition, DIRECTION_LEFT), greaterThan(cond(eq(_this.velocityX, 0), _this.gestureX, _this.velocityX), 0), lessThan(cond(eq(_this.velocityX, 0), _this.gestureX, _this.velocityX), 0)), _this.isOpen)))]), _this.position]);\n    _this.translateX = cond(eq(_this.drawerPosition, DIRECTION_RIGHT), min(max(multiply(_this.drawerWidth, -1), _this.dragX), 0), max(min(_this.drawerWidth, _this.dragX), 0));\n    _this.progress = cond(eq(_this.drawerWidth, 0), 0, abs(divide(_this.translateX, _this.drawerWidth)));\n    _this.handleGestureEvent = event([{\n      nativeEvent: {\n        x: _this.touchX,\n        translationX: _this.gestureX,\n        velocityX: _this.velocityX\n      }\n    }]);\n    _this.handleGestureStateChange = event([{\n      nativeEvent: {\n        state: function state(s) {\n          return set(_this.gestureState, s);\n        }\n      }\n    }]);\n\n    _this.handleContainerLayout = function (e) {\n      return _this.containerWidth.setValue(e.nativeEvent.layout.width);\n    };\n\n    _this.handleDrawerLayout = function (e) {\n      _this.drawerWidth.setValue(e.nativeEvent.layout.width);\n\n      _this.toggleDrawer(_this.props.open);\n\n      requestAnimationFrame(function () {\n        return requestAnimationFrame(function () {\n          return _this.drawerOpacity.setValue(1);\n        });\n      });\n    };\n\n    _this.toggleDrawer = function (open) {\n      if (_this.currentOpenValue !== open) {\n        _this.nextIsOpen.setValue(open ? TRUE : FALSE);\n\n        _this.currentOpenValue = open;\n      }\n    };\n\n    _this.toggleStatusBar = function (hidden) {\n      var _this$props2 = _this.props,\n          hideStatusBar = _this$props2.hideStatusBarOnOpen,\n          statusBarAnimation = _this$props2.statusBarAnimation;\n\n      if (hideStatusBar && _this.isStatusBarHidden !== hidden) {\n        _this.isStatusBarHidden = hidden;\n        StatusBar.setHidden(hidden, statusBarAnimation);\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(DrawerView, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props3 = this.props,\n          open = _this$props3.open,\n          drawerPosition = _this$props3.drawerPosition,\n          drawerType = _this$props3.drawerType,\n          swipeDistanceThreshold = _this$props3.swipeDistanceThreshold,\n          swipeVelocityThreshold = _this$props3.swipeVelocityThreshold,\n          hideStatusBar = _this$props3.hideStatusBarOnOpen;\n\n      if (typeof this.pendingOpenValue !== 'boolean' || open !== this.pendingOpenValue) {\n        this.toggleDrawer(open);\n      }\n\n      this.pendingOpenValue = undefined;\n\n      if (open !== prevProps.open && hideStatusBar) {\n        this.toggleStatusBar(open);\n      }\n\n      if (prevProps.drawerPosition !== drawerPosition) {\n        this.drawerPosition.setValue(drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT);\n      }\n\n      if (prevProps.drawerType !== drawerType) {\n        this.isDrawerTypeFront.setValue(drawerType === 'front' ? TRUE : FALSE);\n      }\n\n      if (prevProps.swipeDistanceThreshold !== swipeDistanceThreshold) {\n        this.swipeDistanceThreshold.setValue(swipeDistanceThreshold);\n      }\n\n      if (prevProps.swipeVelocityThreshold !== swipeVelocityThreshold) {\n        this.swipeVelocityThreshold.setValue(swipeVelocityThreshold);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.toggleStatusBar(false);\n      this.handleEndInteraction();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props4 = this.props,\n          open = _this$props4.open,\n          swipeEnabled = _this$props4.swipeEnabled,\n          drawerPosition = _this$props4.drawerPosition,\n          drawerType = _this$props4.drawerType,\n          swipeEdgeWidth = _this$props4.swipeEdgeWidth,\n          drawerStyle = _this$props4.drawerStyle,\n          overlayStyle = _this$props4.overlayStyle,\n          renderDrawerContent = _this$props4.renderDrawerContent,\n          renderSceneContent = _this$props4.renderSceneContent,\n          gestureHandlerProps = _this$props4.gestureHandlerProps,\n          overlayAccessibilityLabel = _this$props4.overlayAccessibilityLabel;\n      var isOpen = drawerType === 'permanent' ? true : open;\n      var isRight = drawerPosition === 'right';\n      var contentTranslateX = drawerType === 'front' ? ANIMATED_ZERO : this.translateX;\n      var drawerTranslateX = drawerType === 'back' ? I18nManager.getConstants().isRTL ? multiply(sub(this.containerWidth, this.drawerWidth), isRight ? 1 : -1) : ANIMATED_ZERO : this.translateX;\n      var offset = drawerType === 'back' ? 0 : I18nManager.getConstants().isRTL ? '100%' : multiply(this.drawerWidth, -1);\n      var hitSlop = isRight ? {\n        right: 0,\n        width: isOpen ? undefined : swipeEdgeWidth\n      } : {\n        left: 0,\n        width: isOpen ? undefined : swipeEdgeWidth\n      };\n      var progress = drawerType === 'permanent' ? ANIMATED_ONE : this.progress;\n      return React.createElement(DrawerProgressContext.Provider, {\n        value: progress\n      }, React.createElement(PanGestureHandler, _extends({\n        activeOffsetX: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n        failOffsetY: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n        onGestureEvent: this.handleGestureEvent,\n        onHandlerStateChange: this.handleGestureStateChange,\n        hitSlop: hitSlop,\n        enabled: drawerType !== 'permanent' && swipeEnabled\n      }, gestureHandlerProps), React.createElement(Animated.View, {\n        onLayout: this.handleContainerLayout,\n        style: [styles.main, {\n          flexDirection: drawerType === 'permanent' && !isRight ? 'row-reverse' : 'row'\n        }]\n      }, React.createElement(Animated.View, {\n        style: [styles.content, {\n          transform: drawerType === 'permanent' ? [] : [{\n            translateX: contentTranslateX\n          }]\n        }]\n      }, React.createElement(View, {\n        accessibilityElementsHidden: isOpen && drawerType !== 'permanent',\n        importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',\n        style: styles.content\n      }, renderSceneContent()), drawerType === 'permanent' ? null : React.createElement(Overlay, {\n        progress: progress,\n        onPress: function onPress() {\n          return _this2.toggleDrawer(false);\n        },\n        accessibilityLabel: overlayAccessibilityLabel,\n        style: overlayStyle,\n        accessibilityElementsHidden: !isOpen,\n        importantForAccessibility: isOpen ? 'auto' : 'no-hide-descendants'\n      })), React.createElement(Animated.Code, {\n        exec: this.containerWidth\n      }), drawerType === 'permanent' ? null : React.createElement(Animated.Code, {\n        exec: block([onChange(this.manuallyTriggerSpring, [cond(eq(this.manuallyTriggerSpring, TRUE), [set(this.nextIsOpen, FALSE), call([], function () {\n          return _this2.currentOpenValue = false;\n        })])])])\n      }), React.createElement(Animated.View, {\n        removeClippedSubviews: Platform.OS !== 'ios',\n        onLayout: this.handleDrawerLayout,\n        style: [styles.container, {\n          transform: drawerType === 'permanent' ? [] : [{\n            translateX: drawerTranslateX\n          }],\n          opacity: this.drawerOpacity\n        }, drawerType === 'permanent' ? isRight ? {\n          right: 0\n        } : {\n          left: 0\n        } : [styles.nonPermanent, isRight ? {\n          right: offset\n        } : {\n          left: offset\n        }, {\n          zIndex: drawerType === 'back' ? -1 : 0\n        }], drawerStyle]\n      }, renderDrawerContent()))));\n    }\n  }]);\n\n  return DrawerView;\n}(React.Component);\n\nexport { DrawerView as default };\nvar styles = StyleSheet.create({\n  container: {\n    backgroundColor: 'white',\n    maxWidth: '100%'\n  },\n  nonPermanent: {\n    position: 'absolute',\n    top: 0,\n    bottom: 0,\n    width: DEFAULT_DRAWER_WIDTH\n  },\n  content: {\n    flex: 1\n  },\n  main: _objectSpread({\n    flex: 1\n  }, Platform.select({\n    web: null,\n    default: {\n      overflow: 'hidden'\n    }\n  }))\n});","map":{"version":3,"sources":["views/legacy/Drawer.tsx"],"names":["React","Animated","DrawerProgressContext","GestureState","PanGestureHandler","Overlay","Clock","Value","onChange","clockRunning","startClock","stopClock","spring","abs","add","and","block","call","cond","divide","eq","event","greaterThan","lessThan","max","min","multiply","neq","or","set","sub","TRUE","FALSE","NOOP","UNSET","DIRECTION_LEFT","DIRECTION_RIGHT","SWIPE_DISTANCE_MINIMUM","DEFAULT_DRAWER_WIDTH","SPRING_CONFIG","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","ANIMATED_ZERO","ANIMATED_ONE","DrawerView","Component","componentDidUpdate","prevProps","open","drawerPosition","drawerType","swipeDistanceThreshold","swipeVelocityThreshold","hideStatusBarOnOpen","hideStatusBar","props","pendingOpenValue","toggleDrawer","undefined","toggleStatusBar","setValue","isDrawerTypeFront","componentWillUnmount","handleEndInteraction","interactionHandle","InteractionManager","clearInteractionHandle","handleStartInteraction","createInteractionHandle","getDrawerWidth","drawerStyle","dimensions","width","StyleSheet","flatten","endsWith","percentage","Number","replace","isFinite","clock","isOpen","nextIsOpen","isSwiping","initialDrawerWidth","gestureState","UNDETERMINED","touchX","velocityX","gestureX","offsetX","position","containerWidth","drawerWidth","drawerOpacity","touchDistanceFromDrawer","currentOpenValue","isStatusBarHidden","manuallyTriggerSpring","transitionTo","toValue","frameTime","state","time","finished","velocity","value","Boolean","dragX","onOpen","onClose","forceUpdate","keyboardDismissMode","Keyboard","dismiss","ACTIVE","translateX","progress","handleGestureEvent","nativeEvent","x","translationX","handleGestureStateChange","s","handleContainerLayout","e","layout","handleDrawerLayout","requestAnimationFrame","hidden","statusBarAnimation","StatusBar","setHidden","render","swipeEnabled","swipeEdgeWidth","overlayStyle","renderDrawerContent","renderSceneContent","gestureHandlerProps","overlayAccessibilityLabel","isRight","contentTranslateX","drawerTranslateX","I18nManager","getConstants","isRTL","offset","hitSlop","right","left","styles","main","flexDirection","content","transform","Platform","OS","container","opacity","nonPermanent","zIndex","create","backgroundColor","maxWidth","top","bottom","flex","select","web","default","overflow"],"mappings":"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","sourceRoot":"../../../../src","sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as React from 'react';\nimport { I18nManager, InteractionManager, Keyboard, Platform, StatusBar, StyleSheet, View } from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport DrawerProgressContext from '../../utils/DrawerProgressContext';\nimport { GestureState, PanGestureHandler } from '../GestureHandler';\nimport Overlay from './Overlay';\nconst {\n  Clock,\n  Value,\n  onChange,\n  clockRunning,\n  startClock,\n  stopClock,\n  spring,\n  abs,\n  add,\n  and,\n  block,\n  call,\n  cond,\n  divide,\n  eq,\n  event,\n  greaterThan,\n  lessThan,\n  max,\n  min,\n  multiply,\n  neq,\n  or,\n  set,\n  sub\n} = Animated;\nconst TRUE = 1;\nconst FALSE = 0;\nconst NOOP = 0;\nconst UNSET = -1;\nconst DIRECTION_LEFT = 1;\nconst DIRECTION_RIGHT = -1;\nconst SWIPE_DISTANCE_MINIMUM = 5;\nconst DEFAULT_DRAWER_WIDTH = '80%';\nconst SPRING_CONFIG = {\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n  restDisplacementThreshold: 0.01,\n  restSpeedThreshold: 0.01\n};\nconst ANIMATED_ZERO = new Animated.Value(0);\nconst ANIMATED_ONE = new Animated.Value(1);\nexport default class DrawerView extends React.Component {\n  componentDidUpdate(prevProps) {\n    const {\n      open,\n      drawerPosition,\n      drawerType,\n      swipeDistanceThreshold,\n      swipeVelocityThreshold,\n      hideStatusBarOnOpen: hideStatusBar\n    } = this.props;\n    if (\n    // If we're not in the middle of a transition, sync the drawer's open state\n    typeof this.pendingOpenValue !== 'boolean' || open !== this.pendingOpenValue) {\n      this.toggleDrawer(open);\n    }\n    this.pendingOpenValue = undefined;\n    if (open !== prevProps.open && hideStatusBar) {\n      this.toggleStatusBar(open);\n    }\n    if (prevProps.drawerPosition !== drawerPosition) {\n      this.drawerPosition.setValue(drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT);\n    }\n    if (prevProps.drawerType !== drawerType) {\n      this.isDrawerTypeFront.setValue(drawerType === 'front' ? TRUE : FALSE);\n    }\n    if (prevProps.swipeDistanceThreshold !== swipeDistanceThreshold) {\n      this.swipeDistanceThreshold.setValue(swipeDistanceThreshold);\n    }\n    if (prevProps.swipeVelocityThreshold !== swipeVelocityThreshold) {\n      this.swipeVelocityThreshold.setValue(swipeVelocityThreshold);\n    }\n  }\n  componentWillUnmount() {\n    this.toggleStatusBar(false);\n    this.handleEndInteraction();\n  }\n  handleEndInteraction = () => {\n    if (this.interactionHandle !== undefined) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n      this.interactionHandle = undefined;\n    }\n  };\n  handleStartInteraction = () => {\n    if (this.interactionHandle === undefined) {\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    }\n  };\n  getDrawerWidth = () => {\n    const {\n      drawerStyle,\n      dimensions\n    } = this.props;\n    const {\n      width = DEFAULT_DRAWER_WIDTH\n    } = StyleSheet.flatten(drawerStyle) || {};\n    if (typeof width === 'string' && width.endsWith('%')) {\n      // Try to calculate width if a percentage is given\n      const percentage = Number(width.replace(/%$/, ''));\n      if (Number.isFinite(percentage)) {\n        return dimensions.width * (percentage / 100);\n      }\n    }\n    return typeof width === 'number' ? width : 0;\n  };\n  clock = new Clock();\n  isDrawerTypeFront = new Value(this.props.drawerType === 'front' ? TRUE : FALSE);\n  isOpen = new Value(this.props.open ? TRUE : FALSE);\n  nextIsOpen = new Value(UNSET);\n  isSwiping = new Value(FALSE);\n  initialDrawerWidth = this.getDrawerWidth();\n  gestureState = new Value(GestureState.UNDETERMINED);\n  touchX = new Value(0);\n  velocityX = new Value(0);\n  gestureX = new Value(0);\n  offsetX = new Value(0);\n  position = new Value(this.props.open ? this.initialDrawerWidth * (this.props.drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT) : 0);\n  containerWidth = new Value(this.props.dimensions.width);\n  drawerWidth = new Value(this.initialDrawerWidth);\n  drawerOpacity = new Value(this.props.drawerType === 'permanent' ? 1 : 0);\n  drawerPosition = new Value(this.props.drawerPosition === 'right' ? DIRECTION_RIGHT : DIRECTION_LEFT);\n\n  // Comment stolen from react-native-gesture-handler/DrawerLayout\n  //\n  // While closing the drawer when user starts gesture outside of its area (in greyed\n  // out part of the window), we want the drawer to follow only once finger reaches the\n  // edge of the drawer.\n  // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n  // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n  // an arrow pointing left\n  // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n  //    +---------------+    +---------------+    +---------------+    +---------------+\n  //\n  // For the above to work properly we define animated value that will keep start position\n  // of the gesture. Then we use that value to calculate how much we need to subtract from\n  // the dragX. If the gesture started on the greyed out area we take the distance from the\n  // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n  // drawer be pulled back as soon as you start the pan.\n  //\n  // This is used only when drawerType is \"front\"\n  touchDistanceFromDrawer = cond(this.isDrawerTypeFront, cond(eq(this.drawerPosition, DIRECTION_LEFT), max(\n  // Distance of touch start from left screen edge - Drawer width\n  sub(sub(this.touchX, this.gestureX), this.drawerWidth), 0), min(multiply(\n  // Distance of drawer from left screen edge - Touch start point\n  sub(sub(this.containerWidth, this.drawerWidth), sub(this.touchX, this.gestureX)), DIRECTION_RIGHT), 0)), 0);\n  swipeDistanceThreshold = new Value(this.props.swipeDistanceThreshold);\n  swipeVelocityThreshold = new Value(this.props.swipeVelocityThreshold);\n  currentOpenValue = this.props.open;\n  isStatusBarHidden = false;\n  manuallyTriggerSpring = new Value(FALSE);\n  transitionTo = isOpen => {\n    const toValue = new Value(0);\n    const frameTime = new Value(0);\n    const state = {\n      position: this.position,\n      time: new Value(0),\n      finished: new Value(FALSE),\n      velocity: new Value(0)\n    };\n    return block([cond(clockRunning(this.clock), NOOP, [\n    // Animation wasn't running before\n    // Set the initial values and start the clock\n    set(toValue, multiply(isOpen, this.drawerWidth, this.drawerPosition)), set(frameTime, 0), set(state.time, 0), set(state.finished, FALSE), set(state.velocity, this.velocityX), set(this.isOpen, isOpen), startClock(this.clock), call([], this.handleStartInteraction), set(this.manuallyTriggerSpring, FALSE)]), spring(this.clock, state, {\n      ...SPRING_CONFIG,\n      toValue\n    }), cond(state.finished, [\n    // Reset gesture and velocity from previous gesture\n    set(this.touchX, 0), set(this.gestureX, 0), set(this.velocityX, 0), set(this.offsetX, 0),\n    // When the animation finishes, stop the clock\n    stopClock(this.clock), call([this.isOpen], _ref => {\n      let [value] = _ref;\n      const open = Boolean(value);\n      this.handleEndInteraction();\n      if (open !== this.props.open) {\n        // Sync drawer's state after animation finished\n        // This shouldn't be necessary, but there seems to be an issue on iOS\n        this.toggleDrawer(this.props.open);\n      }\n    })])]);\n  };\n  dragX = block([onChange(this.isOpen, call([this.isOpen], _ref2 => {\n    let [value] = _ref2;\n    const open = Boolean(value);\n    this.currentOpenValue = open;\n\n    // Without this check, the drawer can go to an infinite update <-> animate loop for sync updates\n    if (open !== this.props.open) {\n      // If the mode changed, update state\n      if (open) {\n        this.props.onOpen();\n      } else {\n        this.props.onClose();\n      }\n      this.pendingOpenValue = open;\n\n      // Force componentDidUpdate to fire, whether user does a setState or not\n      // This allows us to detect when the user drops the update and revert back\n      // It's necessary to make sure that the state stays in sync\n      this.forceUpdate();\n    }\n  })), onChange(this.nextIsOpen, cond(neq(this.nextIsOpen, UNSET), [\n  // Stop any running animations\n  cond(clockRunning(this.clock), stopClock(this.clock)),\n  // Update the open value to trigger the transition\n  set(this.isOpen, this.nextIsOpen), set(this.gestureX, 0), set(this.nextIsOpen, UNSET)])),\n  // This block must be after the this.isOpen listener since we check for current value\n  onChange(this.isSwiping,\n  // Listen to updates for this value only when it changes\n  // Without `onChange`, this will fire even if the value didn't change\n  // We don't want to call the listeners if the value didn't change\n  call([this.isSwiping], _ref3 => {\n    let [value] = _ref3;\n    const {\n      keyboardDismissMode\n    } = this.props;\n    if (value === TRUE) {\n      if (keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      this.toggleStatusBar(true);\n    } else {\n      this.toggleStatusBar(this.currentOpenValue);\n    }\n  })), onChange(this.gestureState, cond(eq(this.gestureState, GestureState.ACTIVE), call([], this.handleStartInteraction))), cond(eq(this.gestureState, GestureState.ACTIVE), [cond(this.isSwiping, NOOP, [\n  // We weren't dragging before, set it to true\n  set(this.isSwiping, TRUE),\n  // Also update the drag offset to the last position\n  set(this.offsetX, this.position)]),\n  // Update position with previous offset + gesture distance\n  set(this.position, add(this.offsetX, this.gestureX, this.touchDistanceFromDrawer)),\n  // Stop animations while we're dragging\n  stopClock(this.clock)], [set(this.isSwiping, FALSE), set(this.touchX, 0), this.transitionTo(cond(this.manuallyTriggerSpring, this.isOpen, cond(or(and(greaterThan(abs(this.gestureX), SWIPE_DISTANCE_MINIMUM), greaterThan(abs(this.velocityX), this.swipeVelocityThreshold)), greaterThan(abs(this.gestureX), this.swipeDistanceThreshold)), cond(eq(this.drawerPosition, DIRECTION_LEFT),\n  // If swiped to right, open the drawer, otherwise close it\n  greaterThan(cond(eq(this.velocityX, 0), this.gestureX, this.velocityX), 0),\n  // If swiped to left, open the drawer, otherwise close it\n  lessThan(cond(eq(this.velocityX, 0), this.gestureX, this.velocityX), 0)), this.isOpen)))]), this.position]);\n  translateX = cond(eq(this.drawerPosition, DIRECTION_RIGHT), min(max(multiply(this.drawerWidth, -1), this.dragX), 0), max(min(this.drawerWidth, this.dragX), 0));\n  progress = cond(\n  // Check if the drawer width is available to avoid division by zero\n  eq(this.drawerWidth, 0), 0, abs(divide(this.translateX, this.drawerWidth)));\n  handleGestureEvent = event([{\n    nativeEvent: {\n      x: this.touchX,\n      translationX: this.gestureX,\n      velocityX: this.velocityX\n    }\n  }]);\n  handleGestureStateChange = event([{\n    nativeEvent: {\n      state: s => set(this.gestureState, s)\n    }\n  }]);\n  handleContainerLayout = e => this.containerWidth.setValue(e.nativeEvent.layout.width);\n  handleDrawerLayout = e => {\n    this.drawerWidth.setValue(e.nativeEvent.layout.width);\n    this.toggleDrawer(this.props.open);\n\n    // Until layout is available, drawer is hidden with opacity: 0 by default\n    // Show it in the next frame when layout is available\n    // If we don't delay it until the next frame, there's a visible flicker\n    requestAnimationFrame(() => requestAnimationFrame(() => this.drawerOpacity.setValue(1)));\n  };\n  toggleDrawer = open => {\n    if (this.currentOpenValue !== open) {\n      this.nextIsOpen.setValue(open ? TRUE : FALSE);\n\n      // This value will also be set shortly after as changing this.nextIsOpen changes this.isOpen\n      // However, there's a race condition on Android, so we need to set a bit earlier\n      this.currentOpenValue = open;\n    }\n  };\n  toggleStatusBar = hidden => {\n    const {\n      hideStatusBarOnOpen: hideStatusBar,\n      statusBarAnimation\n    } = this.props;\n    if (hideStatusBar && this.isStatusBarHidden !== hidden) {\n      this.isStatusBarHidden = hidden;\n      StatusBar.setHidden(hidden, statusBarAnimation);\n    }\n  };\n  render() {\n    const {\n      open,\n      swipeEnabled,\n      drawerPosition,\n      drawerType,\n      swipeEdgeWidth,\n      drawerStyle,\n      overlayStyle,\n      renderDrawerContent,\n      renderSceneContent,\n      gestureHandlerProps,\n      overlayAccessibilityLabel\n    } = this.props;\n    const isOpen = drawerType === 'permanent' ? true : open;\n    const isRight = drawerPosition === 'right';\n    const contentTranslateX = drawerType === 'front' ? ANIMATED_ZERO : this.translateX;\n    const drawerTranslateX = drawerType === 'back' ? I18nManager.getConstants().isRTL ? multiply(sub(this.containerWidth, this.drawerWidth), isRight ? 1 : -1) : ANIMATED_ZERO : this.translateX;\n    const offset = drawerType === 'back' ? 0 : I18nManager.getConstants().isRTL ? '100%' : multiply(this.drawerWidth, -1);\n\n    // FIXME: Currently hitSlop is broken when on Android when drawer is on right\n    // https://github.com/software-mansion/react-native-gesture-handler/issues/569\n    const hitSlop = isRight ?\n    // Extend hitSlop to the side of the screen when drawer is closed\n    // This lets the user drag the drawer from the side of the screen\n    {\n      right: 0,\n      width: isOpen ? undefined : swipeEdgeWidth\n    } : {\n      left: 0,\n      width: isOpen ? undefined : swipeEdgeWidth\n    };\n    const progress = drawerType === 'permanent' ? ANIMATED_ONE : this.progress;\n    return /*#__PURE__*/React.createElement(DrawerProgressContext.Provider, {\n      value: progress\n    }, /*#__PURE__*/React.createElement(PanGestureHandler, _extends({\n      activeOffsetX: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n      failOffsetY: [-SWIPE_DISTANCE_MINIMUM, SWIPE_DISTANCE_MINIMUM],\n      onGestureEvent: this.handleGestureEvent,\n      onHandlerStateChange: this.handleGestureStateChange,\n      hitSlop: hitSlop,\n      enabled: drawerType !== 'permanent' && swipeEnabled\n    }, gestureHandlerProps), /*#__PURE__*/React.createElement(Animated.View, {\n      onLayout: this.handleContainerLayout,\n      style: [styles.main, {\n        flexDirection: drawerType === 'permanent' && !isRight ? 'row-reverse' : 'row'\n      }]\n    }, /*#__PURE__*/React.createElement(Animated.View, {\n      style: [styles.content, {\n        transform: drawerType === 'permanent' ?\n        // Reanimated needs the property to be present, but it results in Browser bug\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=20574\n        [] : [{\n          translateX: contentTranslateX\n        }]\n      }]\n    }, /*#__PURE__*/React.createElement(View, {\n      accessibilityElementsHidden: isOpen && drawerType !== 'permanent',\n      importantForAccessibility: isOpen && drawerType !== 'permanent' ? 'no-hide-descendants' : 'auto',\n      style: styles.content\n    }, renderSceneContent()),\n    // Disable overlay if sidebar is permanent\n    drawerType === 'permanent' ? null : /*#__PURE__*/React.createElement(Overlay, {\n      progress: progress,\n      onPress: () => this.toggleDrawer(false),\n      accessibilityLabel: overlayAccessibilityLabel,\n      style: overlayStyle,\n      accessibilityElementsHidden: !isOpen,\n      importantForAccessibility: isOpen ? 'auto' : 'no-hide-descendants'\n    })), /*#__PURE__*/React.createElement(Animated.Code, {\n      // This is needed to make sure that container width updates with `setValue`\n      // Without this, it won't update when not used in styles\n      exec: this.containerWidth\n    }), drawerType === 'permanent' ? null : /*#__PURE__*/React.createElement(Animated.Code, {\n      exec: block([onChange(this.manuallyTriggerSpring, [cond(eq(this.manuallyTriggerSpring, TRUE), [set(this.nextIsOpen, FALSE), call([], () => this.currentOpenValue = false)])])])\n    }), /*#__PURE__*/React.createElement(Animated.View, {\n      removeClippedSubviews: Platform.OS !== 'ios',\n      onLayout: this.handleDrawerLayout,\n      style: [styles.container, {\n        transform: drawerType === 'permanent' ?\n        // Reanimated needs the property to be present, but it results in Browser bug\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=20574\n        [] : [{\n          translateX: drawerTranslateX\n        }],\n        opacity: this.drawerOpacity\n      }, drawerType === 'permanent' ?\n      // Without this, the `left`/`right` values don't get reset\n      isRight ? {\n        right: 0\n      } : {\n        left: 0\n      } : [styles.nonPermanent, isRight ? {\n        right: offset\n      } : {\n        left: offset\n      }, {\n        zIndex: drawerType === 'back' ? -1 : 0\n      }], drawerStyle]\n    }, renderDrawerContent()))));\n  }\n}\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: 'white',\n    maxWidth: '100%'\n  },\n  nonPermanent: {\n    position: 'absolute',\n    top: 0,\n    bottom: 0,\n    width: DEFAULT_DRAWER_WIDTH\n  },\n  content: {\n    flex: 1\n  },\n  main: {\n    flex: 1,\n    ...Platform.select({\n      // FIXME: We need to hide `overflowX` on Web so the translated content doesn't show offscreen.\n      // But adding `overflowX: 'hidden'` prevents content from collapsing the URL bar.\n      web: null,\n      default: {\n        overflow: 'hidden'\n      }\n    })\n  }\n});\n//# sourceMappingURL=Drawer.js.map"]},"metadata":{},"sourceType":"module"}