{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { useState, useEffect } from 'react';\nimport { HybridContext } from \"./../hybrid-overlay/Context\";\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport _useColorScheme from \"react-native-web/dist/exports/useColorScheme\";\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\nimport { useNativeBaseConfig } from \"../NativeBaseContext\";\nexport var useColorMode = function useColorMode() {\n  var _React$useContext = React.useContext(HybridContext),\n      colorModeContext = _React$useContext.colorMode;\n\n  if (colorModeContext === undefined) {\n    throw new Error('useColorMode must be used within a NativeBaseProvider');\n  }\n\n  return colorModeContext;\n};\nexport function useColorModeValue(light, dark) {\n  var _useColorMode = useColorMode(),\n      colorMode = _useColorMode.colorMode;\n\n  return colorMode === 'dark' ? dark : light;\n}\nexport var useAppState = function useAppState() {\n  var subscription = React.useMemo(function () {\n    return {\n      getCurrentValue: function getCurrentValue() {\n        return AppState.currentState;\n      },\n      subscribe: function subscribe(callback) {\n        var subsription = AppState.addEventListener('change', callback);\n        return function () {\n          if (AppState.removeEventListener) {\n            AppState.removeEventListener('change', callback);\n          } else {\n            subsription.remove();\n          }\n        };\n      }\n    };\n  }, []);\n  var isSSR = useNativeBaseConfig('useBreakpointResolvedProps').isSSR;\n\n  if (isSSR) {\n    return 'unknown';\n  } else {\n    return useSyncExternalStore(subscription.subscribe, subscription.getCurrentValue, subscription.getCurrentValue);\n  }\n};\nexport var useColorScheme = function useColorScheme() {\n  var colorScheme = _useColorScheme();\n\n  var _useState = useState(colorScheme),\n      _useState2 = _slicedToArray(_useState, 2),\n      currentScheme = _useState2[0],\n      setCurrentScheme = _useState2[1];\n\n  var appState = useAppState();\n  useEffect(function () {\n    if (appState === 'active') {\n      setCurrentScheme(colorScheme);\n    }\n  }, [appState, colorScheme]);\n  return currentScheme;\n};\nexport function useModeManager(initialColorMode, useSystemColorMode, colorModeManager) {\n  var systemColorMode = useColorScheme();\n\n  if (useSystemColorMode) {\n    initialColorMode = systemColorMode;\n  }\n\n  var _useState3 = useState(initialColorMode),\n      _useState4 = _slicedToArray(_useState3, 2),\n      colorMode = _useState4[0],\n      setRawMode = _useState4[1];\n\n  var setColorMode = React.useCallback(function () {\n    var _ref = _asyncToGenerator(function* (val) {\n      if (colorModeManager) {\n        yield colorModeManager.set(val);\n      }\n\n      setRawMode(val);\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [colorModeManager]);\n  useEffect(function () {\n    if (colorModeManager) {\n      (function () {\n        var _getMode = _asyncToGenerator(function* () {\n          var value = yield colorModeManager.get(initialColorMode);\n\n          if (value && value !== colorMode) {\n            setRawMode(value);\n          }\n        });\n\n        function getMode() {\n          return _getMode.apply(this, arguments);\n        }\n\n        return getMode;\n      })()();\n    }\n  }, [colorMode, initialColorMode, colorModeManager]);\n  useEffect(function () {\n    if (!colorModeManager && useSystemColorMode) {\n      setRawMode(systemColorMode);\n    }\n  }, [systemColorMode, colorModeManager, useSystemColorMode, setRawMode]);\n  return {\n    colorMode: colorMode,\n    setColorMode: setColorMode\n  };\n}\nexport function useAccessibleColors() {\n  var _React$useContext2 = React.useContext(HybridContext),\n      colorModeContext = _React$useContext2.colorMode;\n\n  var toggleAccessibleColors = function toggleAccessibleColors() {\n    return colorModeContext.setAccessibleColors(!colorModeContext.accessibleColors);\n  };\n\n  return [colorModeContext.accessibleColors, colorModeContext.setAccessibleColors, toggleAccessibleColors];\n}","map":{"version":3,"sources":["hooks.tsx"],"names":["useColorMode","colorMode","colorModeContext","React","useAppState","subscription","getCurrentValue","AppState","subscribe","callback","subsription","isSSR","useNativeBaseConfig","useSyncExternalStore","useColorScheme","colorScheme","_useColorScheme","useState","appState","useEffect","setCurrentScheme","systemColorMode","initialColorMode","setColorMode","colorModeManager","setRawMode","value","toggleAccessibleColors"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport type {\n  ColorMode,\n  StorageManager,\n  IColorModeContextProps,\n} from './types';\nimport { HybridContext } from './../hybrid-overlay/Context';\nimport type { IHybridContextProps } from './../hybrid-overlay/types';\nimport { AppState, useColorScheme as _useColorScheme } from 'react-native';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\n\nimport { useNativeBaseConfig } from '../NativeBaseContext';\n\nexport const useColorMode = (): IColorModeContextProps => {\n  const {\n    colorMode: colorModeContext,\n  }: {\n    colorMode: IColorModeContextProps;\n  } = React.useContext<IHybridContextProps>(HybridContext);\n  if (colorModeContext === undefined) {\n    throw new Error('useColorMode must be used within a NativeBaseProvider');\n  }\n  return colorModeContext;\n};\n\nexport function useColorModeValue(light: any, dark: any) {\n  const { colorMode } = useColorMode();\n  return colorMode === 'dark' ? dark : light;\n}\n\nexport const useAppState = () => {\n  const subscription = React.useMemo(\n    () => ({\n      getCurrentValue: () => AppState.currentState,\n      subscribe: (callback: () => void) => {\n        const subsription = AppState.addEventListener('change', callback);\n        return () => {\n          if (AppState.removeEventListener) {\n            // React Native < 0.65\n            AppState.removeEventListener('change', callback);\n          } else {\n            // React Native >= 0.65\n            // @ts-ignore:next-line ignoring ts error as devDependency contains \"@types/react-native\" < 0.65\n            subsription.remove();\n          }\n        };\n      },\n    }),\n    []\n  );\n\n  const isSSR = useNativeBaseConfig('useBreakpointResolvedProps').isSSR;\n\n  if (isSSR) {\n    return 'unknown';\n  } else {\n    // This if statement technically breaks the rules of hooks, but is safe\n    // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useSyncExternalStore(\n      subscription.subscribe,\n      subscription.getCurrentValue,\n      subscription.getCurrentValue\n    );\n  }\n};\n\nexport const useColorScheme = () => {\n  const colorScheme = _useColorScheme();\n  const [currentScheme, setCurrentScheme] = useState(colorScheme);\n  const appState = useAppState();\n\n  useEffect(() => {\n    if (appState === 'active') {\n      setCurrentScheme(colorScheme);\n    }\n  }, [appState, colorScheme]);\n\n  return currentScheme;\n};\n\nexport function useModeManager(\n  initialColorMode: ColorMode,\n  useSystemColorMode: boolean | undefined,\n  colorModeManager?: StorageManager\n) {\n  const systemColorMode = useColorScheme();\n\n  if (useSystemColorMode) {\n    initialColorMode = systemColorMode;\n  }\n\n  const [colorMode, setRawMode] = useState<ColorMode>(initialColorMode);\n  const setColorMode = React.useCallback(\n    async (val: ColorMode) => {\n      if (colorModeManager) {\n        await colorModeManager.set(val);\n      }\n      setRawMode(val);\n    },\n    [colorModeManager]\n  );\n\n  // For initial setting initial color mode from storage\n  useEffect(() => {\n    if (colorModeManager) {\n      (async function getMode() {\n        const value = await colorModeManager.get(initialColorMode);\n        if (value && value !== colorMode) {\n          setRawMode(value);\n        }\n      })();\n    }\n  }, [colorMode, initialColorMode, colorModeManager]);\n\n  // Set system color mode only when user has not passed a colorModeManager\n  useEffect(() => {\n    if (!colorModeManager && useSystemColorMode) {\n      setRawMode(systemColorMode);\n    }\n  }, [systemColorMode, colorModeManager, useSystemColorMode, setRawMode]);\n\n  return { colorMode, setColorMode };\n}\n\nexport function useAccessibleColors(): [\n  boolean,\n  (val: boolean) => void,\n  () => void\n] {\n  const {\n    colorMode: colorModeContext,\n  }: {\n    colorMode: IColorModeContextProps;\n  } = React.useContext<IHybridContextProps>(HybridContext);\n  const toggleAccessibleColors = () =>\n    colorModeContext.setAccessibleColors(!colorModeContext.accessibleColors);\n  return [\n    colorModeContext.accessibleColors,\n    colorModeContext.setAccessibleColors,\n    toggleAccessibleColors,\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}