{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar VELOCITY_FACTOR = 0.2;\nvar MAX_POINTERS = 20;\n\nvar PointerTracker = function () {\n  function PointerTracker() {\n    _classCallCheck(this, PointerTracker);\n\n    _defineProperty(this, \"trackedPointers\", new Map());\n\n    _defineProperty(this, \"touchEventsIds\", new Map());\n\n    _defineProperty(this, \"lastMovedPointerId\", void 0);\n\n    _defineProperty(this, \"cachedAverages\", {\n      x: 0,\n      y: 0\n    });\n\n    this.lastMovedPointerId = NaN;\n\n    for (var i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  _createClass(PointerTracker, [{\n    key: \"addToTracker\",\n    value: function addToTracker(event) {\n      if (this.trackedPointers.has(event.pointerId)) {\n        return;\n      }\n\n      this.lastMovedPointerId = event.pointerId;\n      var newElement = {\n        lastX: event.x,\n        lastY: event.y,\n        timeStamp: event.time,\n        velocityX: 0,\n        velocityY: 0\n      };\n      this.trackedPointers.set(event.pointerId, newElement);\n      this.mapTouchEventId(event.pointerId);\n      this.cachedAverages = {\n        x: this.getLastAvgX(),\n        y: this.getLastAvgY()\n      };\n    }\n  }, {\n    key: \"removeFromTracker\",\n    value: function removeFromTracker(pointerId) {\n      this.trackedPointers.delete(pointerId);\n      this.removeMappedTouchId(pointerId);\n    }\n  }, {\n    key: \"track\",\n    value: function track(event) {\n      var element = this.trackedPointers.get(event.pointerId);\n\n      if (!element) {\n        return;\n      }\n\n      this.lastMovedPointerId = event.pointerId;\n      var dx = event.x - element.lastX;\n      var dy = event.y - element.lastY;\n      var dt = event.time - element.timeStamp;\n      element.velocityX = dx / dt * 1000 * VELOCITY_FACTOR;\n      element.velocityY = dy / dt * 1000 * VELOCITY_FACTOR;\n      element.lastX = event.x;\n      element.lastY = event.y;\n      this.trackedPointers.set(event.pointerId, element);\n      var avgX = this.getLastAvgX();\n      var avgY = this.getLastAvgY();\n      this.cachedAverages = {\n        x: avgX,\n        y: avgY\n      };\n    }\n  }, {\n    key: \"mapTouchEventId\",\n    value: function mapTouchEventId(id) {\n      for (var _ref3 of this.touchEventsIds) {\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var mappedId = _ref2[0];\n        var touchId = _ref2[1];\n\n        if (isNaN(touchId)) {\n          this.touchEventsIds.set(mappedId, id);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"removeMappedTouchId\",\n    value: function removeMappedTouchId(id) {\n      var mappedId = this.getMappedTouchEventId(id);\n\n      if (!isNaN(mappedId)) {\n        this.touchEventsIds.set(mappedId, NaN);\n      }\n    }\n  }, {\n    key: \"getMappedTouchEventId\",\n    value: function getMappedTouchEventId(touchEventId) {\n      for (var _ref6 of this.touchEventsIds.entries()) {\n        var _ref5 = _slicedToArray(_ref6, 2);\n\n        var key = _ref5[0];\n        var value = _ref5[1];\n\n        if (value === touchEventId) {\n          return key;\n        }\n      }\n\n      return NaN;\n    }\n  }, {\n    key: \"getVelocityX\",\n    value: function getVelocityX(pointerId) {\n      var _this$trackedPointers;\n\n      return (_this$trackedPointers = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers === void 0 ? void 0 : _this$trackedPointers.velocityX;\n    }\n  }, {\n    key: \"getVelocityY\",\n    value: function getVelocityY(pointerId) {\n      var _this$trackedPointers2;\n\n      return (_this$trackedPointers2 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers2 === void 0 ? void 0 : _this$trackedPointers2.velocityY;\n    }\n  }, {\n    key: \"getLastX\",\n    value: function getLastX(pointerId) {\n      if (pointerId !== undefined) {\n        var _this$trackedPointers3;\n\n        return (_this$trackedPointers3 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers3 === void 0 ? void 0 : _this$trackedPointers3.lastX;\n      } else {\n        var _this$trackedPointers4;\n\n        return (_this$trackedPointers4 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers4 === void 0 ? void 0 : _this$trackedPointers4.lastX;\n      }\n    }\n  }, {\n    key: \"getLastY\",\n    value: function getLastY(pointerId) {\n      if (pointerId !== undefined) {\n        var _this$trackedPointers5;\n\n        return (_this$trackedPointers5 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers5 === void 0 ? void 0 : _this$trackedPointers5.lastY;\n      } else {\n        var _this$trackedPointers6;\n\n        return (_this$trackedPointers6 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers6 === void 0 ? void 0 : _this$trackedPointers6.lastY;\n      }\n    }\n  }, {\n    key: \"getLastAvgX\",\n    value: function getLastAvgX() {\n      var avgX = this.getSumX() / this.trackedPointers.size;\n      return isNaN(avgX) ? this.cachedAverages.x : avgX;\n    }\n  }, {\n    key: \"getLastAvgY\",\n    value: function getLastAvgY() {\n      var avgY = this.getSumY() / this.trackedPointers.size;\n      return isNaN(avgY) ? this.cachedAverages.y : avgY;\n    }\n  }, {\n    key: \"getSumX\",\n    value: function getSumX(ignoredPointer) {\n      var sumX = 0;\n      this.trackedPointers.forEach(function (value, key) {\n        if (key !== ignoredPointer) {\n          sumX += value.lastX;\n        }\n      });\n      return sumX;\n    }\n  }, {\n    key: \"getSumY\",\n    value: function getSumY(ignoredPointer) {\n      var sumY = 0;\n      this.trackedPointers.forEach(function (value, key) {\n        if (key !== ignoredPointer) {\n          sumY += value.lastY;\n        }\n      });\n      return sumY;\n    }\n  }, {\n    key: \"getTrackedPointersCount\",\n    value: function getTrackedPointersCount() {\n      return this.trackedPointers.size;\n    }\n  }, {\n    key: \"getTrackedPointersID\",\n    value: function getTrackedPointersID() {\n      var keys = [];\n      this.trackedPointers.forEach(function (_value, key) {\n        keys.push(key);\n      });\n      return keys;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.trackedPointers;\n    }\n  }, {\n    key: \"resetTracker\",\n    value: function resetTracker() {\n      this.trackedPointers.clear();\n      this.lastMovedPointerId = NaN;\n\n      for (var i = 0; i < MAX_POINTERS; ++i) {\n        this.touchEventsIds.set(i, NaN);\n      }\n    }\n  }], [{\n    key: \"shareCommonPointers\",\n    value: function shareCommonPointers(stPointers, ndPointers) {\n      return stPointers.some(function (pointerId) {\n        return ndPointers.includes(pointerId);\n      });\n    }\n  }]);\n\n  return PointerTracker;\n}();\n\nexport { PointerTracker as default };","map":{"version":3,"sources":["PointerTracker.ts"],"names":["VELOCITY_FACTOR","MAX_POINTERS","x","y","constructor","i","addToTracker","event","newElement","lastX","lastY","timeStamp","velocityX","velocityY","removeFromTracker","track","element","dx","dy","dt","avgX","avgY","mapTouchEventId","isNaN","removeMappedTouchId","mappedId","getMappedTouchEventId","value","getVelocityX","getVelocityY","getLastX","pointerId","getLastY","getLastAvgX","getLastAvgY","getSumX","sumX","key","getSumY","sumY","getTrackedPointersCount","getTrackedPointersID","keys","getData","resetTracker","shareCommonPointers","stPointers","ndPointers"],"mappings":"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","sourcesContent":["import { AdaptedEvent } from '../interfaces';\n\nexport interface TrackerElement {\n  lastX: number;\n  lastY: number;\n\n  timeStamp: number;\n\n  velocityX: number;\n  velocityY: number;\n}\n\n// Used to scale velocity so that it is similar to velocity in Android/iOS\nconst VELOCITY_FACTOR = 0.2;\nconst MAX_POINTERS = 20;\n\nexport default class PointerTracker {\n  private trackedPointers: Map<number, TrackerElement> = new Map<\n    number,\n    TrackerElement\n  >();\n\n  private touchEventsIds: Map<number, number> = new Map<number, number>();\n\n  private lastMovedPointerId: number;\n\n  private cachedAverages: { x: number; y: number } = { x: 0, y: 0 };\n\n  public constructor() {\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public addToTracker(event: AdaptedEvent): void {\n    if (this.trackedPointers.has(event.pointerId)) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    const newElement: TrackerElement = {\n      lastX: event.x,\n      lastY: event.y,\n      timeStamp: event.time,\n      velocityX: 0,\n      velocityY: 0,\n    };\n\n    this.trackedPointers.set(event.pointerId, newElement);\n    this.mapTouchEventId(event.pointerId);\n\n    this.cachedAverages = {\n      x: this.getLastAvgX(),\n      y: this.getLastAvgY(),\n    };\n  }\n\n  public removeFromTracker(pointerId: number): void {\n    this.trackedPointers.delete(pointerId);\n    this.removeMappedTouchId(pointerId);\n  }\n\n  public track(event: AdaptedEvent): void {\n    const element: TrackerElement = this.trackedPointers.get(\n      event.pointerId\n    ) as TrackerElement;\n\n    if (!element) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    const dx = event.x - element.lastX;\n    const dy = event.y - element.lastY;\n    const dt = event.time - element.timeStamp;\n\n    element.velocityX = (dx / dt) * 1000 * VELOCITY_FACTOR;\n    element.velocityY = (dy / dt) * 1000 * VELOCITY_FACTOR;\n\n    element.lastX = event.x;\n    element.lastY = event.y;\n\n    this.trackedPointers.set(event.pointerId, element);\n\n    const avgX: number = this.getLastAvgX();\n    const avgY: number = this.getLastAvgY();\n\n    this.cachedAverages = {\n      x: avgX,\n      y: avgY,\n    };\n  }\n\n  //Mapping TouchEvents ID\n  private mapTouchEventId(id: number): void {\n    for (const [mappedId, touchId] of this.touchEventsIds) {\n      if (isNaN(touchId)) {\n        this.touchEventsIds.set(mappedId, id);\n        break;\n      }\n    }\n  }\n\n  private removeMappedTouchId(id: number): void {\n    const mappedId: number = this.getMappedTouchEventId(id);\n    if (!isNaN(mappedId)) {\n      this.touchEventsIds.set(mappedId, NaN);\n    }\n  }\n\n  public getMappedTouchEventId(touchEventId: number): number {\n    for (const [key, value] of this.touchEventsIds.entries()) {\n      if (value === touchEventId) {\n        return key;\n      }\n    }\n\n    return NaN;\n  }\n\n  public getVelocityX(pointerId: number): number {\n    return this.trackedPointers.get(pointerId)?.velocityX as number;\n  }\n  public getVelocityY(pointerId: number): number {\n    return this.trackedPointers.get(pointerId)?.velocityY as number;\n  }\n\n  /**\n   * Returns X coordinate of last moved pointer\n   */\n  public getLastX(): number;\n\n  /**\n   *\n   * @param pointerId\n   * Returns X coordinate of given pointer\n   */\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  public getLastX(pointerId: number): number;\n\n  public getLastX(pointerId?: number): number {\n    if (pointerId !== undefined) {\n      return this.trackedPointers.get(pointerId)?.lastX as number;\n    } else {\n      return this.trackedPointers.get(this.lastMovedPointerId)?.lastX as number;\n    }\n  }\n\n  /**\n   * Returns Y coordinate of last moved pointer\n   */\n  public getLastY(): number;\n\n  /**\n   *\n   * @param pointerId\n   * Returns Y coordinate of given pointer\n   */\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  public getLastY(pointerId: number): number;\n\n  public getLastY(pointerId?: number): number {\n    if (pointerId !== undefined) {\n      return this.trackedPointers.get(pointerId)?.lastY as number;\n    } else {\n      return this.trackedPointers.get(this.lastMovedPointerId)?.lastY as number;\n    }\n  }\n\n  // Some handlers use these methods to send average values in native event.\n  // This may happen when pointers have already been removed from tracker (i.e. pointerup event).\n  // In situation when NaN would be sent as a response, we return cached value.\n  // That prevents handlers from crashing\n  public getLastAvgX(): number {\n    const avgX: number = this.getSumX() / this.trackedPointers.size;\n    return isNaN(avgX) ? this.cachedAverages.x : avgX;\n  }\n  public getLastAvgY(): number {\n    const avgY: number = this.getSumY() / this.trackedPointers.size;\n    return isNaN(avgY) ? this.cachedAverages.y : avgY;\n  }\n  public getSumX(ignoredPointer?: number): number {\n    let sumX = 0;\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sumX += value.lastX;\n      }\n    });\n\n    return sumX;\n  }\n  public getSumY(ignoredPointer?: number): number {\n    let sumY = 0;\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sumY += value.lastY;\n      }\n    });\n\n    return sumY;\n  }\n  public getTrackedPointersCount(): number {\n    return this.trackedPointers.size;\n  }\n  public getTrackedPointersID(): number[] {\n    const keys: number[] = [];\n\n    this.trackedPointers.forEach((_value, key) => {\n      keys.push(key);\n    });\n\n    return keys;\n  }\n\n  public getData(): Map<number, TrackerElement> {\n    return this.trackedPointers;\n  }\n\n  public resetTracker(): void {\n    this.trackedPointers.clear();\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public static shareCommonPointers(\n    stPointers: number[],\n    ndPointers: number[]\n  ): boolean {\n    return stPointers.some((pointerId) => ndPointers.includes(pointerId));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}