{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { State } from \"../../State\";\nimport { PointerType } from \"../interfaces\";\nimport PointerTracker from \"./PointerTracker\";\nimport { isPointerInBounds } from \"../utils\";\n\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n\n    _defineProperty(this, \"gestureHandlers\", []);\n\n    _defineProperty(this, \"awaitingHandlers\", []);\n\n    _defineProperty(this, \"handlersToCancel\", []);\n\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n\n  _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"removeHandlerFromOrchestrator\",\n    value: function removeHandlerFromOrchestrator(handler) {\n      this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n      this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n      this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n\n        if (!handler) {\n          continue;\n        }\n\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.gestureHandlers.splice(i, 1);\n          this.cleanHandler(handler);\n        }\n      }\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n\n      var hasToWait = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler && !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler)) {\n          hasToWait = true;\n          return;\n        }\n      });\n      return hasToWait;\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler) {\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n      } else if (handler.getState() !== State.CANCELLED && handler.getState() !== State.FAILED) {\n        if (this.shouldActivate(handler)) {\n          this.makeActive(handler);\n        } else {\n          switch (handler.getState()) {\n            case State.ACTIVE:\n              handler.fail();\n              break;\n\n            case State.BEGAN:\n              handler.cancel();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"shouldActivate\",\n    value: function shouldActivate(handler) {\n      for (var otherHandler of this.gestureHandlers) {\n        if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      for (var i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n          this.cleanHandler(this.awaitingHandlers[i]);\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, sendIfDisabled) {\n      var _this2 = this;\n\n      if (!handler.isEnabled() && !sendIfDisabled) {\n        return;\n      }\n\n      this.handlingChangeSemaphore += 1;\n\n      if (this.isFinished(newState)) {\n        this.awaitingHandlers.forEach(function (otherHandler) {\n          if (_this2.shouldHandlerWaitForOther(otherHandler, handler)) {\n            if (newState === State.END) {\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n\n              if (otherHandler.getState() === State.END) {\n                otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n              }\n\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);\n            } else {\n              _this2.tryActivate(otherHandler);\n            }\n          }\n        });\n      }\n\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(newState, oldState);\n        } else if (oldState === State.ACTIVE && (newState === State.CANCELLED || newState === State.FAILED)) {\n          handler.sendEvent(newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(newState, oldState);\n      }\n\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n\n      if (this.awaitingHandlers.indexOf(handler) < 0) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler) {\n      var _this3 = this;\n\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          _this3.handlersToCancel.push(otherHandler);\n        }\n      });\n\n      for (var i = this.handlersToCancel.length - 1; i >= 0; --i) {\n        var _this$handlersToCance;\n\n        (_this$handlersToCance = this.handlersToCancel[i]) === null || _this$handlersToCance === void 0 ? void 0 : _this$handlersToCance.cancel();\n      }\n\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel();\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);\n        }\n      });\n      handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(State.END, State.ACTIVE);\n\n        if (currentState !== State.END) {\n          handler.sendEvent(State.UNDETERMINED, State.END);\n        }\n      }\n\n      if (handler.isAwaiting()) {\n        handler.setAwaiting(false);\n\n        for (var _i2 = 0; _i2 < this.awaitingHandlers.length; ++_i2) {\n          if (this.awaitingHandlers[_i2] === handler) {\n            this.awaitingHandlers.splice(_i2, 1);\n          }\n        }\n      }\n\n      this.handlersToCancel = [];\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      var alreadyExists = false;\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n\n      if (alreadyExists) {\n        return;\n      }\n\n      this.awaitingHandlers.push(handler);\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      var alreadyExists = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n\n      if (alreadyExists) {\n        return;\n      }\n\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n\n      if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === State.ACTIVE)) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getView() !== otherHandler.getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      var overlap = false;\n      handlerPointers.forEach(function (pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n\n        if (isPointerInBounds(handler.getView(), {\n          x: handlerX,\n          y: handlerY\n        }) && isPointerInBounds(otherHandler.getView(), {\n          x: handlerX,\n          y: handlerY\n        })) {\n          overlap = true;\n        }\n      });\n      otherPointers.forEach(function (pointer) {\n        var otherX = otherHandler.getTracker().getLastX(pointer);\n        var otherY = otherHandler.getTracker().getLastY(pointer);\n\n        if (isPointerInBounds(handler.getView(), {\n          x: otherX,\n          y: otherY\n        }) && isPointerInBounds(otherHandler.getView(), {\n          x: otherX,\n          y: otherY\n        })) {\n          overlap = true;\n        }\n      });\n      return overlap;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }, {\n    key: \"cancelMouseAndPenGestures\",\n    value: function cancelMouseAndPenGestures(currentHandler) {\n      this.gestureHandlers.forEach(function (handler) {\n        if (handler.getPointerType() !== PointerType.MOUSE && handler.getPointerType() !== PointerType.PEN) {\n          return;\n        }\n\n        if (handler !== currentHandler) {\n          handler.cancel();\n        } else {\n          handler.getTracker().resetTracker();\n        }\n      });\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) {\n        GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      }\n\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n\n  return GestureHandlerOrchestrator;\n}();\n\nexport { GestureHandlerOrchestrator as default };\n\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","cleanHandler","handler","Number","removeHandlerFromOrchestrator","cleanupFinishedHandlers","i","hasOtherHandlerToWaitFor","hasToWait","otherHandler","tryActivate","State","shouldActivate","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","makeActive","currentState","addAwaitingHandler","alreadyExists","recordHandlerIfNotPresent","shouldHandlerWaitForOther","canRunSimultaneously","gh1","gh2","shouldHandlerBeCancelledBy","handlerPointers","otherPointers","PointerTracker","checkOverlap","overlap","pointer","handlerX","handlerY","x","y","isPointerInBounds","otherX","otherY","isFinished","state","cancelMouseAndPenGestures","PointerType","getInstance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}