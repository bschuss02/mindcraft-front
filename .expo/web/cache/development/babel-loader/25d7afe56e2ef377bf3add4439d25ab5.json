{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { EventTypes } from \"../interfaces\";\n\nvar RotationGestureDetector = function () {\n  function RotationGestureDetector(callbacks) {\n    _classCallCheck(this, RotationGestureDetector);\n\n    _defineProperty(this, \"onRotationBegin\", void 0);\n\n    _defineProperty(this, \"onRotation\", void 0);\n\n    _defineProperty(this, \"onRotationEnd\", void 0);\n\n    _defineProperty(this, \"currentTime\", 0);\n\n    _defineProperty(this, \"previousTime\", 0);\n\n    _defineProperty(this, \"previousAngle\", 0);\n\n    _defineProperty(this, \"rotation\", 0);\n\n    _defineProperty(this, \"anchorX\", 0);\n\n    _defineProperty(this, \"anchorY\", 0);\n\n    _defineProperty(this, \"isInProgress\", false);\n\n    _defineProperty(this, \"keyPointers\", [NaN, NaN]);\n\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  _createClass(RotationGestureDetector, [{\n    key: \"updateCurrent\",\n    value: function updateCurrent(event, tracker) {\n      this.previousTime = this.currentTime;\n      this.currentTime = event.time;\n\n      var _this$keyPointers = _slicedToArray(this.keyPointers, 2),\n          firstPointerID = _this$keyPointers[0],\n          secondPointerID = _this$keyPointers[1];\n\n      var firstPointerX = tracker.getLastX(firstPointerID);\n      var firstPointerY = tracker.getLastY(firstPointerID);\n      var secondPointerX = tracker.getLastX(secondPointerID);\n      var secondPointerY = tracker.getLastY(secondPointerID);\n      var vectorX = secondPointerX - firstPointerX;\n      var vectorY = secondPointerY - firstPointerY;\n      this.anchorX = (firstPointerX + secondPointerX) / 2;\n      this.anchorY = (firstPointerY + secondPointerY) / 2;\n      var angle = -Math.atan2(vectorY, vectorX);\n      this.rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;\n      this.previousAngle = angle;\n\n      if (this.rotation > Math.PI) {\n        this.rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI) {\n        this.rotation += Math.PI;\n      }\n\n      if (this.rotation > Math.PI / 2) {\n        this.rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI / 2) {\n        this.rotation += Math.PI;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (!this.isInProgress) {\n        return;\n      }\n\n      this.isInProgress = false;\n      this.keyPointers = [NaN, NaN];\n      this.onRotationEnd(this);\n    }\n  }, {\n    key: \"setKeyPointers\",\n    value: function setKeyPointers(tracker) {\n      if (this.keyPointers[0] && this.keyPointers[1]) {\n        return;\n      }\n\n      var pointerIDs = tracker.getData().keys();\n      this.keyPointers[0] = pointerIDs.next().value;\n      this.keyPointers[1] = pointerIDs.next().value;\n    }\n  }, {\n    key: \"onTouchEvent\",\n    value: function onTouchEvent(event, tracker) {\n      switch (event.eventType) {\n        case EventTypes.DOWN:\n          this.isInProgress = false;\n          break;\n\n        case EventTypes.ADDITIONAL_POINTER_DOWN:\n          if (this.isInProgress) {\n            break;\n          }\n\n          this.isInProgress = true;\n          this.previousTime = event.time;\n          this.previousAngle = NaN;\n          this.setKeyPointers(tracker);\n          this.updateCurrent(event, tracker);\n          this.onRotationBegin(this);\n          break;\n\n        case EventTypes.MOVE:\n          if (!this.isInProgress) {\n            break;\n          }\n\n          this.updateCurrent(event, tracker);\n          this.onRotation(this);\n          break;\n\n        case EventTypes.ADDITIONAL_POINTER_UP:\n          if (!this.isInProgress) {\n            break;\n          }\n\n          if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n            this.finish();\n          }\n\n          break;\n\n        case EventTypes.UP:\n          if (this.isInProgress) {\n            this.finish();\n          }\n\n          break;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getTimeDelta\",\n    value: function getTimeDelta() {\n      return this.currentTime + this.previousTime;\n    }\n  }, {\n    key: \"getAnchorX\",\n    value: function getAnchorX() {\n      return this.anchorX;\n    }\n  }, {\n    key: \"getAnchorY\",\n    value: function getAnchorY() {\n      return this.anchorY;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return this.rotation;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.keyPointers = [NaN, NaN];\n      this.isInProgress = false;\n    }\n  }]);\n\n  return RotationGestureDetector;\n}();\n\nexport { RotationGestureDetector as default };","map":{"version":3,"sources":["RotationGestureDetector.ts"],"names":["constructor","callbacks","updateCurrent","event","firstPointerX","tracker","firstPointerY","secondPointerX","secondPointerY","vectorX","vectorY","angle","Math","Number","finish","setKeyPointers","pointerIDs","onTouchEvent","EventTypes","getTimeDelta","getAnchorX","getAnchorY","getRotation","reset"],"mappings":"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","sourcesContent":["import { AdaptedEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener\n{\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (detector: RotationGestureDetector) => boolean;\n  onRotationEnd: (detector: RotationGestureDetector) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private rotation = 0;\n\n  private anchorX = 0;\n  private anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(event: AdaptedEvent, tracker: PointerTracker): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerX: number = tracker.getLastX(firstPointerID);\n    const firstPointerY: number = tracker.getLastY(firstPointerID);\n    const secondPointerX: number = tracker.getLastX(secondPointerID);\n    const secondPointerY: number = tracker.getLastY(secondPointerID);\n\n    const vectorX: number = secondPointerX - firstPointerX;\n    const vectorY: number = secondPointerY - firstPointerY;\n\n    this.anchorX = (firstPointerX + secondPointerX) / 2;\n    this.anchorY = (firstPointerY + secondPointerY) / 2;\n\n    //Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n\n    this.rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n\n  private finish(): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.getData().keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(event: AdaptedEvent, tracker: PointerTracker): boolean {\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish();\n        }\n\n        break;\n\n      case EventTypes.UP:\n        if (this.isInProgress) {\n          this.finish();\n        }\n        break;\n    }\n\n    return true;\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime + this.previousTime;\n  }\n\n  public getAnchorX(): number {\n    return this.anchorX;\n  }\n\n  public getAnchorY(): number {\n    return this.anchorY;\n  }\n\n  public getRotation(): number {\n    return this.rotation;\n  }\n\n  public reset(): void {\n    this.keyPointers = [NaN, NaN];\n    this.isInProgress = false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}